<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>HAUS TAINACH – VR (Quest 3)</title>

  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-blink-controls@0.4.3/dist/aframe-blink-controls.min.js"></script>

  <style>
    html,body{margin:0;height:100%;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto;}
    .hud{
      position:fixed; left:10px; right:10px; top:10px; z-index:10;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      pointer-events:auto;
    }
    .btn{
      appearance:none; border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.55); color:#fff;
      border-radius:14px; padding:12px 14px; font-size:14px;
      cursor:pointer; backdrop-filter: blur(10px);
    }
    .btn.primary{
      background:#e53935;
      border:1px solid rgba(255,255,255,.28);
      box-shadow: 0 10px 28px rgba(229,57,53,.35);
      font-weight:800;
    }
    .pill{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.10);
      border-radius:999px; padding:8px 12px; font-size:13px;
      color:rgba(255,255,255,.85);
    }
    .sliderWrap{
      display:flex; align-items:center; gap:8px;
      padding:8px 12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      border-radius:999px;
    }
    .sliderWrap label{font-size:12px;color:rgba(255,255,255,.85)}
    .sliderWrap input[type="range"]{width:180px}
    .sliderWrap span{font-size:12px;color:rgba(255,255,255,.85);min-width:64px;text-align:right}
    .hint{
      position:fixed; left:10px; right:10px; bottom:10px; z-index:10;
      background:rgba(0,0,0,.45); color:rgba(255,255,255,.88);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px; padding:10px 12px; font-size:12px; line-height:1.35;
      backdrop-filter: blur(10px);
    }
  </style>
</head>

<body>

  <div class="hud">
    <button id="enterVR" class="btn primary" type="button">ENTER VR</button>
    <button id="back" class="btn" type="button">← zurück</button>

    <span id="modePill" class="pill">Modus: DROHNE (12m)</span>
    <button id="modeDrone" class="btn" type="button">Drohne 12m</button>
    <button id="modeGround" class="btn" type="button">Boden 1.6m</button>

    <!-- HTML-Slider (außerhalb VR sichtbar). In VR steuerst du das über A-Menü + Slider. -->
    <div class="sliderWrap" title="Skybox Radius: kleiner = mehr Parallax-Warp beim Gehen, größer = ruhiger">
      <label for="skyR">Sky</label>
      <input id="skyR" type="range" min="500" max="8000" step="100" value="3000" />
      <span id="skyRVal">3000</span>
    </div>
  </div>

  <div class="hint">
    Quest 3 Controls: Links Stick = Walk · Rechts Stick = Snap‑Turn · Links Trigger = Teleport · <b>A</b> = Menü (Mode + Sky Slider)
  </div>

  <a-scene xr-mode-ui="enabled: true" renderer="colorManagement: true" background="color: #000">

    <a-assets>
      <!-- Optional: Wenn vorhanden, VR nimmt das leichtere Bild automatisch -->
      <img id="panoImg" src="TAINACH_PANO_VR.jpg" crossorigin="anonymous" />
      <a-asset-item id="house" src="HAUS_TAINACH.glb"></a-asset-item>
    </a-assets>

    <!-- Panorama Sky -->
    <a-sky id="sky" src="#panoImg" rotation="0 -90 0" geometry="radius: 3000"></a-sky>

    <!-- Licht -->
    <a-entity light="type: hemisphere; intensity: 0.95; color: #ffffff; groundColor: #444"></a-entity>
    <a-entity light="type: directional; intensity: 0.85" position="6 10 6"></a-entity>

    <!-- Teleport-Fläche: UNSICHTBAR (kein schwarzer Boden), aber raycastbar -->
    <a-plane
      id="ground"
      rotation="-90 0 0"
      position="0 0 0"
      width="800"
      height="800"
      material="transparent: true; opacity: 0.0"
      visible="true">
    </a-plane>

    <!-- Haus: auto-ground setzt minY -> 0 -->
    <a-entity
      id="houseEnt"
      gltf-model="#house"
      rotation="90 -90 0"
      scale="12 12 12"
      position="0 0 -6"
      auto-ground="offset: 0">
    </a-entity>

    <!-- Player Rig -->
    <a-entity
      id="player"
      position="0 0 0"
      quest3-locomotion="speed: 1.35; strafeSpeed: 1.15; snapAngle: 30; snapCooldownMs: 320; baseY: 0; bounds: 380;">

      <!-- Head (Desktop fallback). In VR übernimmt Headset die Pose -->
      <a-entity id="head" camera look-controls position="0 1.6 0"></a-entity>

      <!-- Left Hand: Teleport -->
      <a-entity
        id="leftHand"
        oculus-touch-controls="hand: left"
        blink-controls="cameraRig: #player; teleportOrigin: #head; collisionEntities: #ground; button: trigger; rotateOnTeleport: true;">
      </a-entity>

      <!-- Right Hand: Snap-Turn + UI Ray -->
      <a-entity
        id="rightHand"
        oculus-touch-controls="hand: right"
        raycaster="objects: .ui; far: 6"
        cursor="rayOrigin: entity; fuse: false"
        line="color: #ffffff; opacity: 0.75">
      </a-entity>
    </a-entity>

    <!-- VR Menü (A Taste): Mode + Sky Slider (drag) -->
    <a-entity id="vrMenu" visible="false">
      <a-plane width="0.78" height="0.34" color="#111" opacity="0.86"></a-plane>
      <a-text value="VR MENU" color="#fff" position="-0.36 0.13 0.01" width="1.6"></a-text>

      <a-text id="vrModeTxt" value="MODE: DRONE (12m)" color="#ddd" position="-0.36 0.07 0.01" width="1.6"></a-text>
      <a-text id="vrSkyTxt" value="SKY RADIUS: 3000" color="#ddd" position="-0.36 0.02 0.01" width="1.6"></a-text>

      <!-- Mode buttons -->
      <a-plane id="vrBtnDrone" class="ui" width="0.22" height="0.08" color="#2b2b2b" position="-0.22 -0.07 0.01"></a-plane>
      <a-text value="DRONE" color="#fff" position="-0.30 -0.095 0.02" width="1.0"></a-text>

      <a-plane id="vrBtnGround" class="ui" width="0.22" height="0.08" color="#2b2b2b" position="0.05 -0.07 0.01"></a-plane>
      <a-text value="GROUND" color="#fff" position="-0.01 -0.095 0.02" width="1.0"></a-text>

      <a-plane id="vrBtnReset" class="ui" width="0.18" height="0.08" color="#2b2b2b" position="0.30 -0.07 0.01"></a-plane>
      <a-text value="RESET" color="#fff" position="0.245 -0.095 0.02" width="1.0"></a-text>

      <!-- Sky Slider bar -->
      <a-entity id="vrSliderGroup" position="-0.34 -0.16 0.02">
        <a-plane id="vrSliderBar" class="ui" width="0.56" height="0.045" color="#222" opacity="0.95"></a-plane>
        <a-plane id="vrSliderFill" width="0.01" height="0.045" color="#e53935" position="-0.275 0 0.001"></a-plane>
        <a-circle id="vrSliderKnob" class="ui" radius="0.022" color="#ffffff" position="-0.275 0 0.01"></a-circle>
      </a-entity>

      <a-text value="Drag Slider (A menu) · Teleport/Walk bleibt aktiv" color="#aaa" position="-0.36 -0.26 0.01" width="1.8"></a-text>
    </a-entity>

  </a-scene>

  <script>
    // ========== Basics ==========
    const scene = document.querySelector('a-scene');
    document.getElementById('enterVR').addEventListener('click', () => scene?.enterVR?.());
    document.getElementById('back').addEventListener('click', () => location.href = 'index.html');

    const panoImg = document.getElementById('panoImg');
    panoImg.addEventListener('error', () => { panoImg.src = 'TAINACH_PANO.jpg'; });

    const sky = document.getElementById('sky');
    const ground = document.getElementById('ground');
    const player = document.getElementById('player');
    const head = document.getElementById('head');
    const rightHand = document.getElementById('rightHand');

    // ========== Auto-ground model ==========
    AFRAME.registerComponent('auto-ground', {
      schema: { offset: {default: 0} },
      init: function(){
        this.el.addEventListener('model-loaded', () => {
          const obj = this.el.getObject3D('mesh');
          if (!obj) return;
          const box = new THREE.Box3().setFromObject(obj);
          const minY = box.min.y;
          this.el.object3D.position.y -= minY;
          this.el.object3D.position.y += this.data.offset;
        });
      }
    });

    // ========== Locomotion + Snap Turn ==========
    AFRAME.registerComponent('quest3-locomotion', {
      schema: {
        speed: {default: 1.35},
        strafeSpeed: {default: 1.15},
        deadzone: {default: 0.18},
        snapAngle: {default: 30},
        snapCooldownMs: {default: 320},
        baseY: {default: 0},
        bounds: {default: 380}
      },
      init: function () {
        this.left = {x:0,y:0};
        this.rightX = 0;
        this.teleportActive = false;
        this.lastSnapTime = 0;

        this.leftHand = document.getElementById('leftHand');
        this.rightHand = document.getElementById('rightHand');
        this.head = document.getElementById('head');

        if (this.leftHand) {
          this.leftHand.addEventListener('thumbstickmoved', (e) => {
            this.left.x = e.detail.x || 0;
            this.left.y = e.detail.y || 0;
          });
          this.leftHand.addEventListener('triggerdown', () => { this.teleportActive = true; });
          this.leftHand.addEventListener('triggerup', () => { this.teleportActive = false; });
        }
        if (this.rightHand) {
          this.rightHand.addEventListener('thumbstickmoved', (e) => {
            this.rightX = e.detail.x || 0;
          });
        }

        this._vForward = new THREE.Vector3();
        this._vRight = new THREE.Vector3();
        this._vDelta = new THREE.Vector3();
      },
      tick: function (time, dt) {
        const d = this.data;
        const dtS = dt / 1000;

        // Snap Turn (right stick)
        const x = this.rightX;
        const TH = 0.78;
        if (Math.abs(x) > TH && (time - this.lastSnapTime) > d.snapCooldownMs) {
          const sign = x > 0 ? -1 : 1;
          this.el.object3D.rotation.y += THREE.MathUtils.degToRad(d.snapAngle * sign);
          this.lastSnapTime = time;
        }

        // Walk (left stick) - stop while aiming teleport
        if (!this.teleportActive) {
          let ax = this.left.x, ay = this.left.y;
          if (Math.abs(ax) < d.deadzone) ax = 0;
          if (Math.abs(ay) < d.deadzone) ay = 0;

          if (!(ax === 0 && ay === 0)) {
            const headObj = this.head?.object3D || this.el.object3D;
            headObj.getWorldDirection(this._vForward);
            this._vForward.y = 0; this._vForward.normalize();
            this._vRight.set(-this._vForward.z, 0, this._vForward.x);

            const moveForward = -ay;
            const moveStrafe = ax;

            this._vDelta.set(0,0,0);
            this._vDelta.addScaledVector(this._vForward, moveForward * d.speed * dtS);
            this._vDelta.addScaledVector(this._vRight, moveStrafe * d.strafeSpeed * dtS);
            this.el.object3D.position.add(this._vDelta);
          }
        }

        // Clamp bounds + lock height (also after teleport)
        const b = d.bounds;
        this.el.object3D.position.x = THREE.MathUtils.clamp(this.el.object3D.position.x, -b, b);
        this.el.object3D.position.z = THREE.MathUtils.clamp(this.el.object3D.position.z, -b, b);
        this.el.object3D.position.y = d.baseY;
      }
    });

    // ========== Mode (Drone + Ground) ==========
    const modePill = document.getElementById('modePill');

    const DRONE_H = 12.0;  // Drohnenhöhe (m) – wenn anders: hier ändern
    const EYE_H = 1.6;     // Headset/Augenhöhe
    const DRONE_BASEY = DRONE_H - EYE_H;

    let currentMode = 'drone';

    function setModeDrone(){
      currentMode = 'drone';
      ground.setAttribute('position', `0 ${DRONE_BASEY} 0`);
      player.setAttribute('position', `0 ${DRONE_BASEY} 0`);
      player.setAttribute('quest3-locomotion', 'baseY', DRONE_BASEY);
      modePill.textContent = `Modus: DROHNE (${DRONE_H.toFixed(0)}m)`;
      syncVrTexts();
    }
    function setModeGround(){
      currentMode = 'ground';
      ground.setAttribute('position', `0 0 0`);
      player.setAttribute('position', `0 0 0`);
      player.setAttribute('quest3-locomotion', 'baseY', 0);
      modePill.textContent = 'Modus: BODEN (1.6m)';
      syncVrTexts();
    }

    document.getElementById('modeDrone').addEventListener('click', setModeDrone);
    document.getElementById('modeGround').addEventListener('click', setModeGround);

    // Default: Drone (passt zum Drohnen-Pano)
    setModeDrone();

    // ========== Sky Radius Slider (HTML + VR) ==========
    const skyR = document.getElementById('skyR');
    const skyRVal = document.getElementById('skyRVal');

    const SKY_MIN = 500;
    const SKY_MAX = 8000;

    let skyRadius = Number(skyR.value) || 3000;

    function setSkyRadius(r){
      skyRadius = Math.max(SKY_MIN, Math.min(SKY_MAX, Math.round(r / 50) * 50));
      sky.setAttribute('geometry', `radius: ${skyRadius}`);
      skyR.value = String(skyRadius);
      skyRVal.textContent = String(skyRadius);
      syncVrTexts();
      updateVrSliderVisual();
    }

    skyR.addEventListener('input', () => setSkyRadius(Number(skyR.value)));
    setSkyRadius(skyRadius);

    // ========== VR Menu (A) + VR Slider Drag ==========
    const vrMenu = document.getElementById('vrMenu');
    const vrModeTxt = document.getElementById('vrModeTxt');
    const vrSkyTxt = document.getElementById('vrSkyTxt');

    const vrBtnDrone = document.getElementById('vrBtnDrone');
    const vrBtnGround = document.getElementById('vrBtnGround');
    const vrBtnReset = document.getElementById('vrBtnReset');

    const vrSliderBar = document.getElementById('vrSliderBar');
    const vrSliderFill = document.getElementById('vrSliderFill');
    const vrSliderKnob = document.getElementById('vrSliderKnob');

    const SLIDER_W = 0.56; // must match vrSliderBar width
    const SLIDER_HALF = SLIDER_W / 2;

    let menuOpen = false;
    let draggingSky = false;
    let lastHitPoint = null;

    function syncVrTexts(){
      vrModeTxt.setAttribute('value', currentMode === 'drone' ? `MODE: DRONE (${DRONE_H.toFixed(0)}m)` : 'MODE: GROUND (1.6m)');
      vrSkyTxt.setAttribute('value', `SKY RADIUS: ${skyRadius}`);
    }

    function placeMenuInFront(){
      const headPos = new THREE.Vector3();
      head.object3D.getWorldPosition(headPos);

      const dir = new THREE.Vector3();
      head.object3D.getWorldDirection(dir);
      dir.y = 0; dir.normalize();

      const p = headPos.clone().add(dir.multiplyScalar(0.95));
      p.y = headPos.y - 0.28;

      vrMenu.setAttribute('position', `${p.x} ${p.y} ${p.z}`);

      vrMenu.object3D.lookAt(headPos);
      vrMenu.object3D.rotation.x = 0;
      vrMenu.object3D.rotation.z = 0;

      syncVrTexts();
      updateVrSliderVisual();
    }

    function toggleMenu(){
      menuOpen = !menuOpen;
      vrMenu.setAttribute('visible', menuOpen);
      draggingSky = false;
      lastHitPoint = null;
      if (menuOpen) placeMenuInFront();
    }

    // Right controller A = menu
    rightHand.addEventListener('abuttondown', toggleMenu);

    // Buttons inside menu (ray click)
    vrBtnDrone.addEventListener('click', setModeDrone);
    vrBtnGround.addEventListener('click', setModeGround);
    vrBtnReset.addEventListener('click', () => {
      // reset to origin of current plane
      if (currentMode === 'drone'){
        player.object3D.position.set(0, DRONE_BASEY, 0);
        player.object3D.rotation.set(0,0,0);
      } else {
        player.object3D.position.set(0, 0, 0);
        player.object3D.rotation.set(0,0,0);
      }
    });

    // Raycaster intersection tracking (for slider drag)
    rightHand.addEventListener('raycaster-intersection', (evt) => {
      const hits = evt.detail.intersections || [];
      if (!hits.length) return;

      // find intersection with slider bar or knob
      const hit = hits.find(h => h.object && (h.object.el === vrSliderBar || h.object.el === vrSliderKnob));
      if (hit) {
        lastHitPoint = hit.point.clone();
        if (draggingSky) updateSkyFromWorldPoint(lastHitPoint);
      }
    });

    // Start dragging when pressing on bar/knob
    vrSliderBar.addEventListener('mousedown', () => { if (menuOpen) draggingSky = true; });
    vrSliderKnob.addEventListener('mousedown', () => { if (menuOpen) draggingSky = true; });

    // Stop dragging on trigger up
    rightHand.addEventListener('triggerup', () => { draggingSky = false; });

    function updateSkyFromWorldPoint(worldPoint){
      // Convert intersection into slider local coordinates
      const p = worldPoint.clone();
      vrSliderBar.object3D.worldToLocal(p);

      // p.x is along slider bar
      const x = THREE.MathUtils.clamp(p.x, -SLIDER_HALF, SLIDER_HALF);
      const t = (x + SLIDER_HALF) / (SLIDER_W); // 0..1

      const r = SKY_MIN + t * (SKY_MAX - SKY_MIN);
      setSkyRadius(r);
    }

    function updateVrSliderVisual(){
      // knob x from skyRadius
      const t = (skyRadius - SKY_MIN) / (SKY_MAX - SKY_MIN);
      const x = -SLIDER_HALF + t * SLIDER_W;

      vrSliderKnob.setAttribute('position', `${x} 0 0.01`);

      // fill: width from 0..t
      const fillW = Math.max(0.01, t * SLIDER_W);
      const fillX = -SLIDER_HALF + fillW / 2;

      vrSliderFill.setAttribute('width', fillW);
      vrSliderFill.setAttribute('position', `${fillX} 0 0.001`);
    }

    // Ensure menu stays in front if user turns head a lot (optional light follow)
    // If you want it fixed: comment out.
    scene.addEventListener('tick', () => {
      if (menuOpen) {
        // keep distance but allow mild drift correction
        // (not every frame re-lookAt to avoid jitter)
      }
    });
  </script>

</body>
</html>
